<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenTraceDecode: Session handling</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="sigrok-logo-notext.png"/></td>
  <td id="projectalign">
   <div id="projectname">OpenTraceDecode<span id="projectnumber">&#160;unreleased development snapshot</span>
   </div>
   <div id="projectbrief">sigrok protocol decoding library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Session handling</div></div>
</div><!--header-->
<div class="contents">

<p>Starting and handling decoding sessions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga35b50cd6acbef05e5756312b27002803" id="r_ga35b50cd6acbef05e5756312b27002803"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00258.html#ab6fe8fd245a46558f9f1858611a03522">OTD_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#ga35b50cd6acbef05e5756312b27002803">otd_session_new</a> (struct <a class="el" href="a00165.html">otd_session</a> **sess)</td></tr>
<tr class="memdesc:ga35b50cd6acbef05e5756312b27002803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a decoding session.  <br /></td></tr>
<tr class="separator:ga35b50cd6acbef05e5756312b27002803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad004c3c733af11a5d262f9d12cd4e0fe" id="r_gad004c3c733af11a5d262f9d12cd4e0fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00258.html#ab6fe8fd245a46558f9f1858611a03522">OTD_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#gad004c3c733af11a5d262f9d12cd4e0fe">otd_session_start</a> (struct <a class="el" href="a00165.html">otd_session</a> *sess)</td></tr>
<tr class="memdesc:gad004c3c733af11a5d262f9d12cd4e0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a decoding session.  <br /></td></tr>
<tr class="separator:gad004c3c733af11a5d262f9d12cd4e0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e23480b9872bddca2b1d502be2e27e0" id="r_ga1e23480b9872bddca2b1d502be2e27e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00258.html#ab6fe8fd245a46558f9f1858611a03522">OTD_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#ga1e23480b9872bddca2b1d502be2e27e0">otd_session_metadata_set</a> (struct <a class="el" href="a00165.html">otd_session</a> *sess, int key, GVariant *data)</td></tr>
<tr class="memdesc:ga1e23480b9872bddca2b1d502be2e27e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a metadata configuration key in a session.  <br /></td></tr>
<tr class="separator:ga1e23480b9872bddca2b1d502be2e27e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06f225c625d4bed27430fc0bf9940bca" id="r_ga06f225c625d4bed27430fc0bf9940bca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00258.html#ab6fe8fd245a46558f9f1858611a03522">OTD_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#ga06f225c625d4bed27430fc0bf9940bca">otd_session_send</a> (struct <a class="el" href="a00165.html">otd_session</a> *sess, uint64_t abs_start_samplenum, uint64_t abs_end_samplenum, const uint8_t *inbuf, uint64_t inbuflen, uint64_t unitsize)</td></tr>
<tr class="memdesc:ga06f225c625d4bed27430fc0bf9940bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a chunk of logic sample data to a running decoder session.  <br /></td></tr>
<tr class="separator:ga06f225c625d4bed27430fc0bf9940bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8654a21446400e6045097e22c28b1869" id="r_ga8654a21446400e6045097e22c28b1869"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00258.html#ab6fe8fd245a46558f9f1858611a03522">OTD_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#ga8654a21446400e6045097e22c28b1869">otd_session_send_eof</a> (struct <a class="el" href="a00165.html">otd_session</a> *sess)</td></tr>
<tr class="memdesc:ga8654a21446400e6045097e22c28b1869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Communicate the end of the stream of sample data to the session.  <br /></td></tr>
<tr class="separator:ga8654a21446400e6045097e22c28b1869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00a506b773898e40b801edb5efbcd2e2" id="r_ga00a506b773898e40b801edb5efbcd2e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00258.html#ab6fe8fd245a46558f9f1858611a03522">OTD_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#ga00a506b773898e40b801edb5efbcd2e2">otd_session_terminate_reset</a> (struct <a class="el" href="a00165.html">otd_session</a> *sess)</td></tr>
<tr class="memdesc:ga00a506b773898e40b801edb5efbcd2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminate currently executing decoders in a session, reset internal state.  <br /></td></tr>
<tr class="separator:ga00a506b773898e40b801edb5efbcd2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff3d623695f72762cc7120228d4bf2b3" id="r_gaff3d623695f72762cc7120228d4bf2b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00258.html#ab6fe8fd245a46558f9f1858611a03522">OTD_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#gaff3d623695f72762cc7120228d4bf2b3">otd_session_destroy</a> (struct <a class="el" href="a00165.html">otd_session</a> *sess)</td></tr>
<tr class="memdesc:gaff3d623695f72762cc7120228d4bf2b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a decoding session.  <br /></td></tr>
<tr class="separator:gaff3d623695f72762cc7120228d4bf2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac32b5d806af220243d84a95c7e655a00" id="r_gac32b5d806af220243d84a95c7e655a00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00258.html#ab6fe8fd245a46558f9f1858611a03522">OTD_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html#gac32b5d806af220243d84a95c7e655a00">otd_pd_output_callback_add</a> (struct <a class="el" href="a00165.html">otd_session</a> *sess, int output_type, <a class="el" href="a00258.html#a365ddc1ce1879a0f3e1b58555b3198b7">otd_pd_output_callback</a> cb, void *cb_data)</td></tr>
<tr class="memdesc:gac32b5d806af220243d84a95c7e655a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register/add a decoder output callback function.  <br /></td></tr>
<tr class="separator:gac32b5d806af220243d84a95c7e655a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Starting and handling decoding sessions. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gac32b5d806af220243d84a95c7e655a00" name="gac32b5d806af220243d84a95c7e655a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac32b5d806af220243d84a95c7e655a00">&#9670;&#160;</a></span>otd_pd_output_callback_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00258.html#ab6fe8fd245a46558f9f1858611a03522">OTD_API</a> int otd_pd_output_callback_add </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00165.html">otd_session</a> *&#160;</td>
          <td class="paramname"><em>sess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>output_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00258.html#a365ddc1ce1879a0f3e1b58555b3198b7">otd_pd_output_callback</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register/add a decoder output callback function. </p>
<p>The function will be called when a protocol decoder sends output back to the PD controller (except for Python objects, which only go up the stack).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sess</td><td>The output session in which to register the callback. Must not be NULL. </td></tr>
    <tr><td class="paramname">output_type</td><td>The output type this callback will receive. Only one callback per output type can be registered. </td></tr>
    <tr><td class="paramname">cb</td><td>The function to call. Must not be NULL. </td></tr>
    <tr><td class="paramname">cb_data</td><td>Private data for the callback function. Can be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>0.3.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00068_source.html#l00393">393</a> of file <a class="el" href="a00068_source.html">session.c</a>.</p>

<p class="reference">References <a class="el" href="a00062_source.html#l00078">otd_session::callbacks</a>, <a class="el" href="a00258_source.html#l00346">otd_pd_callback::cb</a>, <a class="el" href="a00258_source.html#l00347">otd_pd_callback::cb_data</a>, <a class="el" href="a00062_source.html#l00115">otd_dbg</a>, <a class="el" href="a00258_source.html#l00070">OTD_ERR_ARG</a>, <a class="el" href="a00258_source.html#l00067">OTD_OK</a>, <a class="el" href="a00258_source.html#l00345">otd_pd_callback::output_type</a>, and <a class="el" href="a00080_source.html#l00034">output_type_name()</a>.</p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="a00088_gac32b5d806af220243d84a95c7e655a00_cgraph.png" border="0" usemap="#aa00088_gac32b5d806af220243d84a95c7e655a00_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="gaff3d623695f72762cc7120228d4bf2b3" name="gaff3d623695f72762cc7120228d4bf2b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff3d623695f72762cc7120228d4bf2b3">&#9670;&#160;</a></span>otd_session_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00258.html#ab6fe8fd245a46558f9f1858611a03522">OTD_API</a> int otd_session_destroy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00165.html">otd_session</a> *&#160;</td>
          <td class="paramname"><em>sess</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a decoding session. </p>
<p>All decoder instances and output callbacks are properly released.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sess</td><td>The session to be destroyed. Must not be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OTD_OK upon success, a (negative) error code otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.3.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00068_source.html#l00357">357</a> of file <a class="el" href="a00068_source.html">session.c</a>.</p>

<p class="reference">References <a class="el" href="a00062_source.html#l00078">otd_session::callbacks</a>, <a class="el" href="a00062_source.html#l00075">otd_session::di_list</a>, <a class="el" href="a00062_source.html#l00115">otd_dbg</a>, <a class="el" href="a00258_source.html#l00070">OTD_ERR_ARG</a>, <a class="el" href="a00258_source.html#l00067">OTD_OK</a>, <a class="el" href="a00258_source.html#l00252">otd_decoder_inst::sess</a>, and <a class="el" href="a00062_source.html#l00072">otd_session::session_id</a>.</p>

</div>
</div>
<a id="ga1e23480b9872bddca2b1d502be2e27e0" name="ga1e23480b9872bddca2b1d502be2e27e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e23480b9872bddca2b1d502be2e27e0">&#9670;&#160;</a></span>otd_session_metadata_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00258.html#ab6fe8fd245a46558f9f1858611a03522">OTD_API</a> int otd_session_metadata_set </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00165.html">otd_session</a> *&#160;</td>
          <td class="paramname"><em>sess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GVariant *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a metadata configuration key in a session. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sess</td><td>The session to configure. Must not be NULL. </td></tr>
    <tr><td class="paramname">key</td><td>The configuration key (OTD_CONF_*). </td></tr>
    <tr><td class="paramname">data</td><td>The new value for the key, as a GVariant with GVariantType appropriate to that key. A floating reference can be passed in; its refcount will be sunk and unreferenced after use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OTD_OK upon success, a (negative) error code otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.3.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00068_source.html#l00159">159</a> of file <a class="el" href="a00068_source.html">session.c</a>.</p>

<p class="reference">References <a class="el" href="a00062_source.html#l00075">otd_session::di_list</a>, <a class="el" href="a00258_source.html#l00141">OTD_CONF_SAMPLERATE</a>, <a class="el" href="a00062_source.html#l00115">otd_dbg</a>, <a class="el" href="a00062_source.html#l00118">otd_err</a>, <a class="el" href="a00258_source.html#l00070">OTD_ERR_ARG</a>, <a class="el" href="a00258_source.html#l00067">OTD_OK</a>, <a class="el" href="a00258_source.html#l00252">otd_decoder_inst::sess</a>, and <a class="el" href="a00062_source.html#l00072">otd_session::session_id</a>.</p>

</div>
</div>
<a id="ga35b50cd6acbef05e5756312b27002803" name="ga35b50cd6acbef05e5756312b27002803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35b50cd6acbef05e5756312b27002803">&#9670;&#160;</a></span>otd_session_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00258.html#ab6fe8fd245a46558f9f1858611a03522">OTD_API</a> int otd_session_new </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00165.html">otd_session</a> **&#160;</td>
          <td class="paramname"><em>sess</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a decoding session. </p>
<p>A session holds all decoder instances, their stack relationships and output callbacks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sess</td><td>A pointer which will hold a pointer to a newly initialized session on return. Must not be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OTD_OK upon success, a (negative) error code otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.3.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00068_source.html#l00061">61</a> of file <a class="el" href="a00068_source.html">session.c</a>.</p>

<p class="reference">References <a class="el" href="a00062_source.html#l00115">otd_dbg</a>, <a class="el" href="a00258_source.html#l00070">OTD_ERR_ARG</a>, and <a class="el" href="a00258_source.html#l00067">OTD_OK</a>.</p>

</div>
</div>
<a id="ga06f225c625d4bed27430fc0bf9940bca" name="ga06f225c625d4bed27430fc0bf9940bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06f225c625d4bed27430fc0bf9940bca">&#9670;&#160;</a></span>otd_session_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00258.html#ab6fe8fd245a46558f9f1858611a03522">OTD_API</a> int otd_session_send </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00165.html">otd_session</a> *&#160;</td>
          <td class="paramname"><em>sess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>abs_start_samplenum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>abs_end_samplenum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>inbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>inbuflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>unitsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a chunk of logic sample data to a running decoder session. </p>
<p>If no channel map has been set up, the logic samples must be arranged in channel order, in the least amount of space possible. The default channel set consists of all required channels + all optional channels.</p>
<p>The size of a sample in inbuf is 'unitsize' bytes. If no channel map has been configured, it is the minimum number of bytes needed to store the default channels.</p>
<p>The calls to this function must provide the samples that shall be used by the protocol decoder</p><ul>
<li>in the correct order ([...]5, 6, 4, 7, 8[...] is a bug),</li>
<li>starting from sample zero (2, 3, 4, 5, 6[...] is a bug),</li>
<li>consecutively, with no gaps (0, 1, 2, 4, 5[...] is a bug).</li>
</ul>
<p>The start- and end-sample numbers are absolute sample numbers (relative to the start of the whole capture/file/stream), i.e. they are not relative sample numbers within the chunk specified by 'inbuf' and 'inbuflen'.</p>
<p>Correct example (4096 samples total, 4 chunks @ 1024 samples each): otd_session_send(s, 0,    1023, inbuf, 1024, 1); otd_session_send(s, 1024, 2047, inbuf, 1024, 1); otd_session_send(s, 2048, 3071, inbuf, 1024, 1); otd_session_send(s, 3072, 4095, inbuf, 1024, 1);</p>
<p>The chunk size ('inbuflen') can be arbitrary and can differ between calls.</p>
<p>Correct example (4096 samples total, 7 chunks @ various samples each): otd_session_send(s, 0,    1023, inbuf, 1024, 1); otd_session_send(s, 1024, 1123, inbuf,  100, 1); otd_session_send(s, 1124, 1423, inbuf,  300, 1); otd_session_send(s, 1424, 1642, inbuf,  219, 1); otd_session_send(s, 1643, 2047, inbuf,  405, 1); otd_session_send(s, 2048, 3071, inbuf, 1024, 1); otd_session_send(s, 3072, 4095, inbuf, 1024, 1);</p>
<p>INCORRECT example (4096 samples total, 4 chunks @ 1024 samples each, but the start- and end-samplenumbers are not absolute): otd_session_send(s, 0,    1023, inbuf, 1024, 1); otd_session_send(s, 0,    1023, inbuf, 1024, 1); otd_session_send(s, 0,    1023, inbuf, 1024, 1); otd_session_send(s, 0,    1023, inbuf, 1024, 1);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sess</td><td>The session to use. Must not be NULL. </td></tr>
    <tr><td class="paramname">abs_start_samplenum</td><td>The absolute starting sample number for the buffer's sample set, relative to the start of capture. </td></tr>
    <tr><td class="paramname">abs_end_samplenum</td><td>The absolute ending sample number for the buffer's sample set, relative to the start of capture. </td></tr>
    <tr><td class="paramname">inbuf</td><td>Pointer to sample data. Must not be NULL. </td></tr>
    <tr><td class="paramname">inbuflen</td><td>Length in bytes of the buffer. Must be &gt; 0. </td></tr>
    <tr><td class="paramname">unitsize</td><td>The number of bytes per sample. Must be &gt; 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OTD_OK upon success, a (negative) error code otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.4.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00068_source.html#l00262">262</a> of file <a class="el" href="a00068_source.html">session.c</a>.</p>

<p class="reference">References <a class="el" href="a00258_source.html#l00272">otd_decoder_inst::abs_end_samplenum</a>, <a class="el" href="a00258_source.html#l00269">otd_decoder_inst::abs_start_samplenum</a>, <a class="el" href="a00062_source.html#l00075">otd_session::di_list</a>, <a class="el" href="a00258_source.html#l00275">otd_decoder_inst::inbuf</a>, <a class="el" href="a00258_source.html#l00278">otd_decoder_inst::inbuflen</a>, <a class="el" href="a00258_source.html#l00070">OTD_ERR_ARG</a>, <a class="el" href="a00258_source.html#l00067">OTD_OK</a>, and <a class="el" href="a00258_source.html#l00252">otd_decoder_inst::sess</a>.</p>

</div>
</div>
<a id="ga8654a21446400e6045097e22c28b1869" name="ga8654a21446400e6045097e22c28b1869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8654a21446400e6045097e22c28b1869">&#9670;&#160;</a></span>otd_session_send_eof()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00258.html#ab6fe8fd245a46558f9f1858611a03522">OTD_API</a> int otd_session_send_eof </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00165.html">otd_session</a> *&#160;</td>
          <td class="paramname"><em>sess</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Communicate the end of the stream of sample data to the session. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sess</td><td>The session. Must not be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OTD_OK upon success. A (negative) error code otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.6.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00068_source.html#l00290">290</a> of file <a class="el" href="a00068_source.html">session.c</a>.</p>

<p class="reference">References <a class="el" href="a00062_source.html#l00075">otd_session::di_list</a>, <a class="el" href="a00258_source.html#l00070">OTD_ERR_ARG</a>, <a class="el" href="a00258_source.html#l00067">OTD_OK</a>, and <a class="el" href="a00258_source.html#l00252">otd_decoder_inst::sess</a>.</p>

</div>
</div>
<a id="gad004c3c733af11a5d262f9d12cd4e0fe" name="gad004c3c733af11a5d262f9d12cd4e0fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad004c3c733af11a5d262f9d12cd4e0fe">&#9670;&#160;</a></span>otd_session_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00258.html#ab6fe8fd245a46558f9f1858611a03522">OTD_API</a> int otd_session_start </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00165.html">otd_session</a> *&#160;</td>
          <td class="paramname"><em>sess</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a decoding session. </p>
<p>Decoders, instances and stack must have been prepared beforehand, and all OTD_CONF parameters set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sess</td><td>The session to start. Must not be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OTD_OK upon success, a (negative) error code otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.3.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00068_source.html#l00090">90</a> of file <a class="el" href="a00068_source.html">session.c</a>.</p>

<p class="reference">References <a class="el" href="a00062_source.html#l00075">otd_session::di_list</a>, <a class="el" href="a00062_source.html#l00115">otd_dbg</a>, <a class="el" href="a00258_source.html#l00070">OTD_ERR_ARG</a>, <a class="el" href="a00258_source.html#l00067">OTD_OK</a>, <a class="el" href="a00258_source.html#l00252">otd_decoder_inst::sess</a>, and <a class="el" href="a00062_source.html#l00072">otd_session::session_id</a>.</p>

</div>
</div>
<a id="ga00a506b773898e40b801edb5efbcd2e2" name="ga00a506b773898e40b801edb5efbcd2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00a506b773898e40b801edb5efbcd2e2">&#9670;&#160;</a></span>otd_session_terminate_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00258.html#ab6fe8fd245a46558f9f1858611a03522">OTD_API</a> int otd_session_terminate_reset </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00165.html">otd_session</a> *&#160;</td>
          <td class="paramname"><em>sess</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terminate currently executing decoders in a session, reset internal state. </p>
<p>All decoder instances have their .wait() method terminated, which shall terminate .decode() as well. Afterwards the decoders' optional .reset() method gets executed.</p>
<p>This routine allows callers to abort pending expensive operations, when they are no longer interested in the decoders' results. Note that the decoder state is lost and aborted work cannot resume.</p>
<p>This routine also allows callers to re-use previously created decoder stacks to process new input data which is not related to previously processed input data. This avoids the necessity to re-construct the decoder stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sess</td><td>The session in which to terminate decoders. Must not be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OTD_OK upon success, a (negative) error code otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.5.1 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00068_source.html#l00329">329</a> of file <a class="el" href="a00068_source.html">session.c</a>.</p>

<p class="reference">References <a class="el" href="a00062_source.html#l00075">otd_session::di_list</a>, <a class="el" href="a00258_source.html#l00070">OTD_ERR_ARG</a>, <a class="el" href="a00258_source.html#l00067">OTD_OK</a>, and <a class="el" href="a00258_source.html#l00252">otd_decoder_inst::sess</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Sep 30 2025 08:31:59 for OpenTraceDecode by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
